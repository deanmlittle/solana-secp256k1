use dashu::integer::UBig;
use solana_program::{big_mod_exp::big_mod_exp, secp256k1_recover::secp256k1_recover};

use crate::*;
pub struct Curve;

impl Curve {
    /// ### Curve order ð‘
    /// 
    /// 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
    /// 
    /// This is the order ð‘ of the secp256k1 elliptic curve. The order of the curve is 
    /// a large prime number that determines the size of the cyclic group generated by 
    /// the base point ðº.
    /// 
    /// All valid private keys must be less than ð‘, and all points on the curve are 
    /// within a cyclic group of this order.
    pub const N: [u8; 32] = [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36,
        0x41, 0x41,
    ];

    /// ### Curve order ð‘-2
    /// 
    /// 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413f
    ///
    /// The precomputed value of ð‘âˆ’2 where ð‘ is the order of the secp256k1 curve. 
    /// Used in modular arithmetic operations, such as modular inverse.
    pub const N_SUB_2: [u8; 32] = [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36,
        0x41, 0x3f,
    ];

    /// ### Curve order ð‘-2
    /// 
    /// 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413f
    ///
    /// The precomputed value of ð‘/2 where ð‘ is the order of the secp256k1 curve. 
    /// Used in integer comparison for high S checks in ECDSA.
    pub const N_DIV_2: [u8;32] = [
        0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D, 0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 
        0x20, 0xA0
    ];

    /// ### Field Prime Modulus ð‘ƒ
    /// 
    /// 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
    /// 
    /// This is the prime number ð‘ƒ that defines the finite field over which secp256k1 is defined. 
    /// All arithmetic operations on the curve are performed modulo this prime number.
    pub const P: [u8; 32] = [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff,
        0xfc, 0x2f,
    ];

    /// ### Field Prime Modulus ð‘ƒ-2
    /// 
    /// 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2d
    ///  
    /// This represents ð‘ƒâˆ’2, where ð‘ƒ is the field prime of the secp256k1 curve. This value 
    /// is modular arithmetic operations, such as modular inverse.
    pub const P_SUB_2: [u8; 32] = [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff,
        0xfc, 0x2d,
    ];

    /// ### Field Prime Modulus ð‘ƒ+1/4
    /// 
    /// 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c
    /// 
    /// This is the value ð‘ƒ+1/4, where ð‘ƒ is the field prime. This value is precomputed for 
    /// efficiency and is used in calculating square roots in the field.
    pub const P_1_4: [u8; 32] = [
        0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff,
        0xff, 0x0c,
    ];

    /// ### Generator Point ðº
    /// 
    /// ðº.ð‘‹: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
    /// ðº.ð‘Œ: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
    /// 
    /// ðº is a fixed point on the secp256k1 curve used as the base point for generating public keys. 
    /// All elliptic curve operations are performed with respect to this generator point.
    pub const G: UncompressedPoint = UncompressedPoint([
        0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,
        0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8,
        0x17, 0x98, 0x48, 0x3A, 0xDA, 0x77, 0x26, 0xA3, 0xC4, 0x65, 0x5D, 0xA4, 0xFB, 0xFC, 0x0E,
        0x11, 0x08, 0xA8, 0xFD, 0x17, 0xB4, 0x48, 0xA6, 0x85, 0x54, 0x19, 0x9C, 0x47, 0xD0, 0x8F,
        0xFB, 0x10, 0xD4, 0xB8,
    ]);

    /// ### Mul Mod Point ð‘
    /// 
    /// Multiplies a scalar by another scalar modulus curve order N. Typically used to create
    /// a normalized nonce/private key scalar.
    pub fn mul_mod_n(a: &[u8; 32], b: &[u8; 32]) -> [u8; 32] {
        // Convert the input &[u8; 32] to Integer
        let a_int = UBig::from_be_bytes(a);
        let b_int = UBig::from_be_bytes(b);
        let n_int = UBig::from_be_bytes(&Self::N);

        // Perform the multiplication and modulus operation
        let result = (a_int * b_int) % n_int;

        let mut output = [0u8; 32];
        let result_bytes = result.to_be_bytes();
        let start = 32 - result_bytes.len();
        output[start..].copy_from_slice(&result_bytes);

        output
    }

    /// ### Mul Mod Point ð‘
    /// 
    /// Multiplies a scalar by another scalar modulus curve order N. Typically used to create
    /// a normalized nonce/private key scalar.
    pub fn mul_mod_p(a: &[u8; 32], b: &[u8; 32]) -> [u8; 32] {
        // Convert the input &[u8; 32] to Integer
        let a_int = UBig::from_be_bytes(a);
        let b_int = UBig::from_be_bytes(b);
        let n_int = UBig::from_be_bytes(&Self::P);

        // Perform the multiplication and modulus operation
        let result = (a_int * b_int) % n_int;

        let mut output = [0u8; 32];
        let result_bytes = result.to_be_bytes();
        let start = 32 - result_bytes.len();
        output[start..].copy_from_slice(&result_bytes);

        output
    }

    /// # Fast Mod P
    /// 
    /// Taking advantage of the fact that:
    /// - This function is only used with 256-bit numbers
    /// - We will almost never need to mod P as P is very large
    /// - In the case that we do, we only need to handle the last 8 bytes.
    /// 
    /// We can optimize this beyond 
    pub fn fast_mod_p(a: &mut [u8; 32]) {
        // Transmute the &mut [u8; 32] into &mut [u64; 4]
        let a_u64: &mut [u64; 4] = unsafe { std::mem::transmute(a) };
    
        if a_u64[0] < u64::MAX || a_u64[1] < u64::MAX || a_u64[2] < u64::MAX {
            return;
        }
    
        let max = 0xfffffffefffffc2f;
        if a_u64[3] >= max {
            a_u64[0] = 0;
            a_u64[1] = 0;
            a_u64[2] = 0;
            a_u64[3] -= max;
        }
    }

    /// # Fast Mod N
    /// 
    /// Taking advantage of the fact that:
    /// - This function is only used with 256-bit numbers
    /// - We will almost never need to mod N as N is very large
    /// - In the case that we do, we only need to handle the last 33 bytes.
    /// 
    /// While this may not necessarily be faster in all cases, it will be faster 
    /// on average to veto modulus by the first limb.
    pub fn fast_mod_n(a: &mut [u8; 32]) {
        // Transmute the &mut [u8; 32] into &mut [u64; 4]
        let a_u64: &mut [u64; 4] = unsafe { std::mem::transmute(a) };
    
        // This will almost always be true. Skip to avoid allocating and comparing remaining limbs
        if a_u64[0] < u64::MAX {
            return
        }

        let n1 = u64::MAX-1;
        let n2 = 0xbaaedce6af48a03bu64;
        let n3 = 0xbfd25e8cd036413fu64;
        
        // This will also almost always be true, if not, we can directly set a_u64[0] to 0 and subtract the remaining limbs
        if a_u64[1] < n1 && a_u64[2] < n2 && a_u64[3] < n3 {
            return
        }

        // Subtraction with borrow propagation (from LSB to MSB)
        let (new3, borrow3) = a_u64[3].overflowing_sub(n3);
        let (new2, borrow2) = a_u64[2].overflowing_sub(n2 + borrow3 as u64);
        let (new1, _) = a_u64[1].overflowing_sub(n1 + borrow2 as u64);

        // Assign results back
        a_u64[3] = new3;
        a_u64[2] = new2;
        a_u64[1] = new1;
        a_u64[0] = 0;
    }

    /// ### Negate
    /// 
    /// Negates the provided 32-byte value `ð’Œ` modulo order ð‘ of the Secp256k1 curve.
    /// 
    /// Elliptic curve negation of `ð’Œ` over curve order ð‘.
    /// 
    /// Calculate `ð‘ - ð’Œ` and stores the result back into `ð’Œ`.
    ///
    /// # Example
    ///
    /// ```rust
    /// let mut k: [u8; 32] = [0x01, 0x00, 0x00, ... ]; // Some 32-byte scalar value
    /// negate(&mut k);
    /// // `k` now contains the value (ð‘ - original_k) modulo ð‘.
    /// ```
    /// 
    pub fn negate_n(k: &[u8; 32]) -> [u8;32] {
        let n = UBig::from_be_bytes(&Curve::N);
        let x = ((n.clone() + n.clone() - UBig::from_be_bytes(k)) % n.clone()).to_be_bytes();
        let mut r = [0u8;32];
        r.clone_from_slice(&x);
        r
    }

    pub fn negate_n_assign(k: &mut [u8; 32]) {
        let n = UBig::from_be_bytes(&Curve::N);
        let x = ((n.clone() + n.clone() - UBig::from_be_bytes(k)) % n.clone()).to_be_bytes();
        k.clone_from_slice(&x);
    }

    pub fn negate_p(k: &[u8; 32]) -> [u8;32] {
        let p = UBig::from_be_bytes(&Curve::P);
        let x = ((p.clone() + p.clone() - UBig::from_be_bytes(k)) % p.clone()).to_be_bytes();
        let mut r = [0u8;32];
        r.clone_from_slice(&x);
        r
    }

    pub fn negate_p_assign(k: &mut [u8; 32]) {
        let p = UBig::from_be_bytes(&Curve::P);
        let x = ((p.clone() + p.clone() - UBig::from_be_bytes(k)) % p.clone()).to_be_bytes();
        k.clone_from_slice(&x);
    }

    // TODO: Check which is cheaper on CUs.
    // pub fn negate_p_assign(k: &mut [u8; 32]) {
    //     let mut borrow = 0u8;
    //     for i in (0..32).rev() {
    //         let (res, b) = Self::P[i].overflowing_sub(k[i] + borrow);
    //         k[i] = res;
    //         borrow = if b { 1 } else { 0 };
    //     }
    // }

    /// ### Modular Inverse ð‘
    /// 
    /// Calculates the modular inverse of `ð’Œ` using Fermat's Little Theorem, which states that
    /// for a prime modulus ð‘·, the modular inverse of ð’Œ modulo `ð‘` is given by `ð’Œâ½á´ºâ»Â²â¾ mod ð‘`.
    /// 
    /// The modulus with the exponent `ð‘-2`.
    /// 
    /// The `big_mod_exp` function is used to efficiently compute the modular exponentiation.
    /// 
    /// # Example
    ///
    /// ```rust
    /// let k: [u8; 32] = [0x02, 0x00, 0x00, ... ]; // Some 32-byte scalar value
    /// let inv_k = mod_inv_n(k);
    /// // `inv_k` now contains the value of (ð’Œâ»Â¹) modulo ð‘.
    /// ```
    pub fn mod_inv_n(k: &[u8]) -> [u8; 32] {
        let mut inv_k: [u8; 32] = [0u8; 32];
        inv_k.clone_from_slice(&big_mod_exp(k, &Self::N_SUB_2, &Self::N)[..32]);
        inv_k
    }

    /// ### Modular Inverse ð‘ƒ
    /// 
    /// Calculates the modular inverse of `ð’Œ` using Fermat's Little Theorem, which states that
    /// for a prime modulus ð‘·, the modular inverse of ð’Œ modulo `ð‘ƒ` is given by `ð’Œâ½á´ºâ»Â²â¾ mod ð‘ƒ`.
    /// 
    /// The modulus with the exponent `ð‘ƒ-2`.
    /// 
    /// The `big_mod_exp` function is used to efficiently compute the modular exponentiation.
    /// 
    /// # Example
    ///
    /// ```rust
    /// let k: [u8; 32] = [0x02, 0x00, 0x00, ... ]; // Some 32-byte scalar value
    /// let inv_k = mod_inv_p(k);
    /// // `inv_k` now contains the value of (ð’Œâ»Â¹) modulo ð‘ƒ.
    /// ```
    pub fn mod_inv_p(k: &[u8]) -> [u8; 32] {
        let mut inv_k: [u8; 32] = [0u8; 32];
        inv_k.clone_from_slice(&big_mod_exp(k, &Self::P_SUB_2, &Self::P)[..32]);
        inv_k
    }

    /// ### Mul ðº
    /// 
    /// Abuse Secp256k1Recover to Calculate the UncompressedPoint of Scalar `ð’Œ`
    /// 
    /// # Example
    ///
    /// ```rust
    /// let k: [u8; 32] = [0x01, 0x02, 0x03, ... ]; // Some 32-byte scalar value
    /// let p = mul_g(k);
    /// ```
    pub fn mul_g(k: &[u8;32]) -> Result<UncompressedPoint, Secp256k1Error> {
        let result = Self::mul_mod_n(&k, &Self::G.x());
        let mut s = [0u8;64];
        s[..32].clone_from_slice(&Self::G.x());
        s[32..].clone_from_slice(&result);
        Ok(UncompressedPoint(secp256k1_recover(&[0u8; 32], 0, &s)?.0))
    }

    /// ### Ecmul
    /// 
    /// Abuses Secp256k1 ECRecover to perform efficient ECMul, adding a point to itself N times.
    /// This would ordinarily cost about ~5 million CUs. Perplexingly, we can make it cost way
    /// less than ECAdd by abusing a bespoke half-implementation of an old Ethereum precompile.
    /// In fact, not following the original implementation actually makes it work even better.
    /// 
    /// This unlocks efficient implementations of ECDH, Pedersen commitments.
    /// 
    /// # Example
    ///
    /// ```rust
    /// let k: [u8; 32] = [0x01, 0x02, 0x03, ... ]; // Some 32-byte scalar value
    /// let point: CompressedPoint = [0x03, 0xf8, 0x9b, ... ]; // A compressed or uncompressed point
    /// let p = ecmul::<CompressedPoint>(point, k);
    /// ```
    pub fn ecmul<T: Secp256k1Point>(point: &T, k: &[u8;32]) -> Result<UncompressedPoint, Secp256k1Error> {
        let result = Self::mul_mod_n(&point.x(), k);
        let mut s = [0u8;64];
        s[..32].clone_from_slice(&point.x());
        s[32..].clone_from_slice(&result);
        Ok(UncompressedPoint(secp256k1_recover(&[0u8; 32], point.is_odd() as u8, &s)?.0))
    }
}
